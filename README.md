# Voiture Autonome

![Raspberry Pi](https://img.shields.io/badge/-RaspberryPi-C51A4A?style=for-the-badge&logo=Raspberry-Pi)
![Arduino](https://img.shields.io/badge/-Arduino-00979D?style=for-the-badge&logo=Arduino&logoColor=white)
![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54)
![NumPy](https://img.shields.io/badge/numpy-%23013243.svg?style=for-the-badge&logo=numpy&logoColor=white)

# Table des mati√®res

* [Introduction](#introduction)
* [Premiers pas](#premiers-pas)
  * [Clonage](#clonage)
  * [Installation](#installation)
  * [Configuration](#configuration)
* [Calibration des actionneurs](#calibration-des-actionneurs)
* [Test de communication avec l'Arduino](#test-de-communication-avec-larduino)
* [Ex√©cution du code](#ex√©cution-du-code)
  * [Fichiers associ√©s](#fichiers-associ√©s-2)
  * [Commande dans le terminal](#commande-dans-le-terminal-2)
* [Analyse du *log*](#analyse-du-log)
* [D√©tails de l'algorithme](#d√©tails-de-lalgorithme)
  * [Architecture](#architecture)
  * [Mesure du lidar](#mesure-du-lidar)
  * [Loi de direction](#loi-de-direction)
  * [Loi de vitesse](#loi-de-vitesse)
  * [Interpolation lin√©aire](#interpolation-lin√©aire)
  * [D√©tection de la marche arri√®re](#d√©tection-de-la-marche-arri√®re)
  * [Activation de la marche arri√®re](#activation-de-la-marche-arri√®re)
* [Boot sur RPi 5](#boot-sur-rpi-5)
  * [Configuration PWM](#configuration-pwm)
  * [Cr√©ation d'un alias](#cr√©ation-dun-alias)
* [Contact](#contact)

# Introduction

TODO

# Premiers pas

Pour prendre les premiers pas dans le projet, on doit d'abord t√©l√©charger le code et pr√©parer tout l'environnement dans lequel on travaillera.

## Clonage

Appuyez sur `CTRL+ALT+T` pour ouvrir un terminal et ex√©cutez les commandes ci-dessous (un par ligne) :

```
cd Desktop
git clone https://github.com/l4cer/Voiture-Autonome.git
cd Voiture-Autonome/code_24
```

## Installation

Cr√©ez un environnement virtuel et installez les modules n√©cessaires :

```
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

‚ö†Ô∏è **Important :** pour toutes les sections ci-dessous, ex√©cutez les commandes √† l'int√©rieur du dossier `code_24` et avec l'environnement virtuel activ√© !

## Configuration

- Dans le fichier `core.py`, indiquez √† la ligne 10 si le RPi utilis√© est le 5 ou non.
- Dans le fichier `main.py`, indiquez dans les lignes 38 √† 41 les param√®tres du mat√©riel utilis√©, le *baudrate*, etc.
- Dans le fichier `constants.py`, indiquez √† la ligne 10 l'orientation du LiDAR (angle dans le rep√®re du LiDAR o√π se trouve l'avant du v√©hicule).

# Calibration des actionneurs

Les actionneurs du v√©hicule sont contr√¥l√©s par une technique appel√©e [PWM](https://learn.sparkfun.com/tutorials/pulse-width-modulation/all) (*Pulse Width Modulation*), o√π la position du servomoteur et la vitesse du moteur *brushless* d√©pendent du *duty cycle* appliqu√©. La calibration consiste pr√©cis√©ment √† trouver ces valeurs de *duty cycle* qui permettent √† la direction de tourner au maximum dans les deux sens, ainsi que la valeur qui limitera la vitesse maximale du v√©hicule.

## Fichiers associ√©s

üìÅ `calibrate.py` est le code responsable de la calibration des actionneurs du v√©hicule (servomoteur pour la direction et moteur *brushless* pour la traction). En ex√©cutant ce code, on pourra contr√¥ler manuellement chacun des actionneurs √† partir d'une interface graphique de calibration et de test.

## Commande dans le terminal

```
python calibrate.py
```

Apr√®s avoir ferm√© l'interface graphique, le programme mettra √† jour automatiquement le fichier `constants.py`.

# Test de communication avec l'Arduino

La connexion s√©rie entre le Raspberry Pi et l'Arduino Nano se fait √† l'aide d'un c√¢ble USB vers mini USB. Cette m√™me connexion peut √™tre utilis√©e pour t√©l√©verser des programmes du RPi vers l'Arduino.

## Fichiers associ√©s

üìÅ `arduino.py` est le code responsable de tester la communication s√©rie entre le RPi et l'Arduino. En ex√©cutant ce code, on pourra visualiser les mesures des capteurs envoy√©es de mani√®re s√©rielle par l'Arduino et re√ßues par le RPi.

## Commande dans le terminal

```
python arduino.py
```

Les valeurs re√ßues par la communication s√©rie avec l'Arduino seront affich√©es sous le format :

```
capteur_de_vitesse/distance_de_recul/tension_de_la_batterie
```

Les unit√©s de chaque quantit√© sont respectivement `m/s`, `cm` et `volt`.

# Ex√©cution du code

Maintenant que tout est correctement pr√©par√©, on attache les ceintures ! üèÅ

## Fichiers associ√©s

üìÅ `console.py` est le code responsable de g√©rer les messages imprim√©s dans le terminal et de cr√©er et g√©rer les *logs* de chaque ex√©cution du code principal. Ce code n'est pas ex√©cut√© directement, mais utilis√© par `main.py`.

üìÅ `constants.py` est le code responsable de stocker toutes les constantes qui contr√¥lent le comportement du v√©hicule. Ce code n'est pas ex√©cut√© directement, mais utilis√© par d'autres fichiers. Certaines valeurs sont modifi√©es automatiquement lorsque la calibration des actionneurs est r√©alis√©e, minimisant l'effort.

üìÅ `control.py` est le code responsable de d√©finir les lois de contr√¥le du v√©hicule √† partir des donn√©es sensorielles. On aura une session plus loin pour expliquer en d√©tail les lois de direction et de vitesse. Ce code n'est pas ex√©cut√© directement, mais utilis√© par `main.py`.

üìÅ `core.py` est le code responsable de d√©finir certaines structures de base qui seront utiles dans d'autres parties du projet, telles qu'un contr√¥leur PWM et un gestionnaire de communication s√©rie. Ce code n'est pas ex√©cut√© directement, mais utilis√© par d'autres fichiers.

üìÅ `main.py` est le code responsable de r√©aliser toute la routine d'initialisation des capteurs et actionneurs, le contr√¥le du v√©hicule pendant la course et la fermeture correcte de toutes les structures initialis√©es. Il unit les autres composants du projet. En ex√©cutant ce code, le v√©hicule sera correctement initialis√©, entrant dans une routine d'attente jusqu'√† ce que le signal GO soit donn√© pour le d√©but de la course.

## Commande dans le terminal

```
python main.py
```

Appuyez sur `ENTER` pour d√©marrer et sur `CTRL+C` pour arr√™ter le code. Deux touches sont utilis√©es pour √©viter les arr√™ts accidentels du v√©hicule.

‚ö†Ô∏è **Important :** la commande exacte pour analyser le *log* g√©n√©r√© apr√®s la fin de la course sera copi√©e dans le presse-papiers (*clipboard*).

# Analyse du *log*

IMAGE HERE

## Fichiers associ√©s

üìÅ `multiplot.py` est le code responsable d'interpr√©ter le fichier CSV du *log* et de tracer les graphiques de mani√®re s√©par√©e, permettant l'analyse et l'obtention d'aper√ßus de la mani√®re la plus rapide possible. En ex√©cutant ce code, un √©cran matplotlib avec 5 graphiques sera affich√©. Le graphique le plus √† gauche repr√©sente la mesure du lidar pour l'instant de temps en question, tandis que les 4 autres graphiques montreront une fen√™tre temporelle avec les mesures des m√©triques respectives (les grandeurs et unit√©s sont correctement identifi√©es dans l'interface elle-m√™me).

## Commande dans le terminal

Il suffit de coller la commande copi√©e dans le presse-papiers (*clipboard*).

```
python multiplot.py "../logs/YYYY-MM-DD/HH-MM-SS.csv"
```

Remarquez que `YYYY-MM-DD` repr√©sente l'ann√©e, le mois et le jour, tandis que `HH-MM-SS` repr√©sente l'heure, la minute et la seconde o√π le *log* a √©t√© g√©n√©r√©. Il sera unique pour chaque course et garantit que les *logs* ne se chevauchent pas.

Pour modifier le moment dans le temps des graphiques, utilisez le *slider* en bas √† gauche. Pour un contr√¥le plus pr√©cis, utilisez les fl√®ches du clavier pour passer it√©ration par it√©ration. Appuyez sur la touche `CTRL` tout en utilisant les fl√®ches du clavier pour augmenter la taille du pas.

# D√©tails de l'algorithme

TODO

## Architecture

TODO

## Mesure du lidar

La mesure du lidar se compose d'un vecteur de 360 positions de nombres flottants o√π l'indice repr√©sente l'angle en degr√©s dans le rep√®re du lidar et la valeur allou√©e √† cette position correspond √† la distance respective en m√®tres. Par exemple, l'√©l√©ment √† la position 90 √©quivaut √† la distance mesur√©e sur le c√¥t√© gauche du lidar (pas n√©cessairement √† gauche de la voiture). Notez que les angles sont mesur√©s dans le sens antihoraire.

Le module `rplidar` poss√®de la fonction `iter_scans()` qui permet d'it√©rer sur les balayages du lidar. Il est √† noter que chaque balayage contiendra les distances mesur√©es pour un petit intervalle angulaire, de sorte que nous devons regrouper plusieurs de ces balayages pour composer une mesure du lidar. Lorsque le vecteur de distances comporte plus de 60 points non nuls, il est alors consid√©r√© que la mesure est suffisante pour progresser dans le code.

‚ö†Ô∏è **Important :** comme le module `rplidar` utilise un g√©n√©rateur pour impl√©menter la fonction `iter_scans()`, le code de contr√¥le doit √™tre suffisamment rapide pour ne pas g√©n√©rer d'accumulation de balayages et surcharger le *buffer*.

## Loi de direction

La premi√®re chose √† faire est de filtrer le nuage de points du lidar et de s√©parer la r√©gion d'int√©r√™t principale. La fonction `filter` s√©lectionnera uniquement les points qui se trouvent dans un certain champ de vision du v√©hicule. Ce champ de vision est calcul√© √† partir de l'avant de la voiture et d'une ouverture donn√©e (la moiti√© de chaque c√¥t√©). Ensuite, une convolution sera appliqu√©e pour lisser et r√©duire les erreurs. On peut comprendre la convolution comme une moyenne entre les points voisins. Augmentez `CONVOLUTION_SIZE` pour augmenter cette voisinage et, par cons√©quent, le lissage effectu√©.

Maintenant que le nuage de points a √©t√© correctement trait√©, on trouvera l'angle associ√© au point le plus √©loign√©. De l√©g√®res perturbations seront appliqu√©es vers la droite et vers la gauche de cet angle afin de v√©rifier si la voiture atteindrait d'√©ventuels coins de la piste. Notez que pour v√©rifier la pr√©sence de coins, on utilise la mesure non filtr√©e, car le vecteur filtr√© aura les coins liss√©s.

Supposons qu'un coin a √©t√© trouv√© √† droite du v√©hicule, alors on d√©placera l'angle de direction vers la gauche afin d'√©viter de heurter l'obstacle. Dans ce cas, ce d√©placement serait donn√© par :

```python
delta = -ANGLE_SCALE_FACTOR * (MAX_ANGLE_TO_AVOID_CORNER - r_angle)
```

Les constantes `ANGLE_SCALE_FACTOR` et `MAX_ANGLE_TO_AVOID_CORNER` contr√¥lent le facteur d'augmentation de ce d√©placement et la taille de la perturbation angulaire.

Ainsi, on peut calculer l'angle de direction corrig√© $\alpha$. Cependant, l'angle de braquage effectif des roues $\delta$ sera une fonction de $\alpha$. Cette fonction $f$ est d√©finie dans `STEER_FACTOR` par une carte de points interpol√©s lin√©airement.

$$\delta(\alpha) = \text{sign}(\alpha) \cdot f(\,|\alpha|\,)$$

‚ö†Ô∏è **Important :** un angle de braquage positif indique que la voiture doit tourner √† gauche, tandis qu'une valeur n√©gative indique que la voiture doit tourner √† droite.

## Loi de vitesse

Avec le braquage $\delta$ calcul√©, il est temps de passer √† la vitesse. Un petit c√¥ne sera filtr√© dans la r√©gion frontale du v√©hicule afin de calculer sa distance frontale $d_f$. La vitesse $v$ sera une fonction de $d_f$ et de $\delta$ de la mani√®re suivante :

$$v(d_f, \delta) = \kappa + (1-\kappa) \cdot g(d_f) \cdot h(\,|\delta|\,)$$

o√π $\kappa$ est une constante qui d√©termine l'agressivit√© de la direction. Plus proche de 1, moins la voiture freinera dans les virages, mais le risque de perdre le contr√¥le est √©galement plus √©lev√©. Les fonctions $g$ et $h$ sont d√©finies respectivement dans `SPEED_FACTOR_DIST` et `SPEED_FACTOR_ANG` √† l'aide de cartes de points interpol√©s lin√©airement.

Remarquez que la fonction $h$ vise √† acc√©l√©rer dans les lignes droites (petit braquage) et √† freiner encore plus dans les virages, augmentant la r√©activit√© du v√©hicule.

## Interpolation lin√©aire

TODO

## D√©tection de la marche arri√®re

TODO

## Activation de la marche arri√®re

TODO

# Boot sur RPi 5

Utilisez le [`2023-12-05-raspios-bookworm-arm64.img.tar.xz`](https://downloads.raspberrypi.com/raspios_arm64/images/raspios_arm64-2023-12-06/2023-12-05-raspios-bookworm-arm64.img.xz) pour d√©marrer le RPi 5.

‚ö†Ô∏è **Important :** le noyau utilis√© doit √™tre le 6.1 et il ne faut pas effectuer de mises √† jour, car le noyau 6.6 pr√©sentait certains probl√®mes au moment du d√©veloppement (mars 2024).

## Configuration PWM

Ex√©cutez la commande ci-dessous pour √©diter le fichier en question :

```
sudo nano /boot/firmware/config.txt
```

√Ä la fin du fichier, ajoutez les lignes suivantes :

```
# Enable PWM
dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4
```

Appuyez sur `CTRL+O` pour enregistrer et `CTRL+X` pour quitter l'√©diteur de texte. Red√©marrez le RPi.

## Cr√©ation d'un alias

Ex√©cutez les commandes ci-dessous pour cr√©er et √©diter un fichier de r√®gles :

```
sudo touch /etc/udev/rules.d/99-devices.rules
sudo nano /etc/udev/rules.d/99-devices.rules
```

Ajoutez les lignes suivantes :

```
SUBSYSTEM=="tty", ATTRS{idVendor}=="2341", ATTRS{idProduct}=="8057", SYMLINK+="ttyACM"
SUBSYSTEM=="tty", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="ea60", SYMLINK+="ttyUSB"
```

Appuyez sur `CTRL+O` pour enregistrer et `CTRL+X` pour quitter l'√©diteur de texte. Red√©marrez le RPi ou d√©branchez et rebranchez les p√©riph√©riques.

Les valeurs `idVendor` et `idProduct` peuvent √™tre trouv√©es en ex√©cutant la commande `dmesg`, mais il y a une forte probabilit√© qu'elles soient les m√™mes que celles de la commande ci-dessus.

Ainsi, il n'est pas n√©cessaire de sp√©cifier si le LiDAR est connect√© au port `ttyUSB0` ou `ttyUSB1`, par exemple, √©vitant les erreurs o√π le port change pendant l'ex√©cution du code.

# Contact

En cas de doutes, n'h√©sitez pas √† envoyer un message !

> Filipe **LACERDA**
>
> filipe.lacerda@ensta-paris.fr
>
> +33 7 82 74 86 81
