# Voiture Autonome

![Raspberry Pi](https://img.shields.io/badge/-RaspberryPi-C51A4A?style=for-the-badge&logo=Raspberry-Pi)
![Arduino](https://img.shields.io/badge/-Arduino-00979D?style=for-the-badge&logo=Arduino&logoColor=white)
![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54)
![NumPy](https://img.shields.io/badge/numpy-%23013243.svg?style=for-the-badge&logo=numpy&logoColor=white)

# Table des mati√®res

* [Premiers pas](#premiers-pas)
  * [Clonage](#clonage)
  * [Installation](#installation)
  * [Configuration](#configuration)
* [Calibration des actionneurs](#calibration-des-actionneurs)
* [Test de communication avec l'Arduino](#test-de-communication-avec-larduino)
* [Ex√©cution du code](#ex√©cution-du-code)
  * [Fichiers associ√©s](#fichiers-associ√©s-2)
  * [Commande dans le terminal](#commande-dans-le-terminal-2)
* [Analyse du *log*](#analyse-du-log)
* [D√©tails de l'algorithme](#d√©tails-de-lalgorithme)
  * [Architecture](#architecture)
  * [Mesure du lidar](#mesure-du-lidar)
  * [Loi de direction](#loi-de-direction)
  * [Loi de vitesse](#loi-de-vitesse)
  * [Interpolation lin√©aire](#interpolation-lin√©aire)
  * [D√©tection de la marche arri√®re](#d√©tection-de-la-marche-arri√®re)
  * [Activation de la marche arri√®re](#activation-de-la-marche-arri√®re)
* [Points d'am√©lioration](#points-dam√©lioration)
* [Boot sur RPi 5](#boot-sur-rpi-5)
  * [Configuration PWM](#configuration-pwm)
  * [Cr√©ation d'un alias](#cr√©ation-dun-alias)
* [Contact](#contact)

# Premiers pas

Pour prendre les premiers pas dans le projet, on doit d'abord t√©l√©charger le code et pr√©parer tout l'environnement dans lequel on travaillera.

## Clonage

Appuyez sur `CTRL+ALT+T` pour ouvrir un terminal et ex√©cutez les commandes ci-dessous (un par ligne) :

```
cd Desktop
git clone https://github.com/l4cer/Voiture-Autonome.git
cd Voiture-Autonome/code_24
```

## Installation

Cr√©ez un environnement virtuel et installez les modules n√©cessaires :

```
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

‚ö†Ô∏è **Important :** pour toutes les sections ci-dessous, ex√©cutez les commandes √† l'int√©rieur du dossier `code_24` et avec l'environnement virtuel activ√© !

## Configuration

- Dans le fichier `core.py`, indiquez √† la ligne 10 si le RPi utilis√© est le 5 ou non.
- Dans le fichier `main.py`, indiquez dans les lignes 38 √† 41 les param√®tres du mat√©riel utilis√©, le *baudrate*, etc.
- Dans le fichier `constants.py`, indiquez √† la ligne 10 l'orientation du LiDAR (angle dans le rep√®re du LiDAR o√π se trouve l'avant du v√©hicule).

# Calibration des actionneurs

Les actionneurs du v√©hicule sont contr√¥l√©s par une technique appel√©e [PWM](https://learn.sparkfun.com/tutorials/pulse-width-modulation/all) (*Pulse Width Modulation*), o√π la position du servomoteur et la vitesse du moteur *brushless* d√©pendent du *duty cycle* appliqu√©. La calibration consiste pr√©cis√©ment √† trouver ces valeurs de *duty cycle* qui permettent √† la direction de tourner au maximum dans les deux sens, ainsi que la valeur qui limitera la vitesse maximale du v√©hicule.

## Fichiers associ√©s

üìÅ `calibrate.py` est le code responsable de la calibration des actionneurs du v√©hicule (servomoteur pour la direction et moteur *brushless* pour la traction). En ex√©cutant ce code, on pourra contr√¥ler manuellement chacun des actionneurs √† partir d'une interface graphique de calibration et de test.

## Commande dans le terminal

```
python calibrate.py
```

Apr√®s avoir ferm√© l'interface graphique, le programme mettra √† jour automatiquement le fichier `constants.py`.

# Test de communication avec l'Arduino

La connexion s√©rie entre le Raspberry Pi et l'Arduino Nano se fait √† l'aide d'un c√¢ble USB vers mini USB. Cette m√™me connexion peut √™tre utilis√©e pour t√©l√©verser des programmes du RPi vers l'Arduino.

## Fichiers associ√©s

üìÅ `arduino.py` est le code responsable de tester la communication s√©rie entre le RPi et l'Arduino. En ex√©cutant ce code, on pourra visualiser les mesures des capteurs envoy√©es de mani√®re s√©rielle par l'Arduino et re√ßues par le RPi.

## Commande dans le terminal

```
python arduino.py
```

Les valeurs re√ßues par la communication s√©rie avec l'Arduino seront affich√©es sous le format :

```
capteur_de_vitesse/distance_de_recul/tension_de_la_batterie
```

Les unit√©s de chaque quantit√© sont respectivement `m/s`, `cm` et `volt`.

# Ex√©cution du code

Maintenant que tout est correctement pr√©par√©, on attache les ceintures ! üèÅ

## Fichiers associ√©s

üìÅ `console.py` est le code responsable de g√©rer les messages imprim√©s dans le terminal et de cr√©er et g√©rer les *logs* de chaque ex√©cution du code principal. Ce code n'est pas ex√©cut√© directement, mais utilis√© par `main.py`.

üìÅ `constants.py` est le code responsable de stocker toutes les constantes qui contr√¥lent le comportement du v√©hicule. Ce code n'est pas ex√©cut√© directement, mais utilis√© par d'autres fichiers. Certaines valeurs sont modifi√©es automatiquement lorsque la calibration des actionneurs est r√©alis√©e, minimisant l'effort.

üìÅ `control.py` est le code responsable de d√©finir les lois de contr√¥le du v√©hicule √† partir des donn√©es sensorielles. On aura une session plus loin pour expliquer en d√©tail les lois de direction et de vitesse. Ce code n'est pas ex√©cut√© directement, mais utilis√© par `main.py`.

üìÅ `core.py` est le code responsable de d√©finir certaines structures de base qui seront utiles dans d'autres parties du projet, telles qu'un contr√¥leur PWM et un gestionnaire de communication s√©rie. Ce code n'est pas ex√©cut√© directement, mais utilis√© par d'autres fichiers.

üìÅ `main.py` est le code responsable de r√©aliser toute la routine d'initialisation des capteurs et actionneurs, le contr√¥le du v√©hicule pendant la course et la fermeture correcte de toutes les structures initialis√©es. Il unit les autres composants du projet. En ex√©cutant ce code, le v√©hicule sera correctement initialis√©, entrant dans une routine d'attente jusqu'√† ce que le signal GO soit donn√© pour le d√©but de la course.

## Commande dans le terminal

```
python main.py
```

Appuyez sur `ENTER` pour d√©marrer et sur `CTRL+C` pour arr√™ter le code. Deux touches sont utilis√©es pour √©viter les arr√™ts accidentels du v√©hicule.

‚ö†Ô∏è **Important :** la commande exacte pour analyser le *log* g√©n√©r√© apr√®s la fin de la course sera copi√©e dans le presse-papiers (*clipboard*).

# Analyse du *log*

![figure 1](images/1.png)
**Figure 1.** analyse du *log* `v3_qualif_1.csv`.

## Fichiers associ√©s

üìÅ `multiplot.py` est le code responsable d'interpr√©ter le fichier CSV du *log* et de tracer les graphiques de mani√®re s√©par√©e, permettant l'analyse et l'obtention d'aper√ßus de la mani√®re la plus rapide possible. En ex√©cutant ce code, un √©cran matplotlib avec 5 graphiques sera affich√©. Le graphique le plus √† gauche repr√©sente la mesure du lidar pour l'instant de temps en question, tandis que les 4 autres graphiques montreront une fen√™tre temporelle avec les mesures des m√©triques respectives (les grandeurs et unit√©s sont correctement identifi√©es dans l'interface elle-m√™me).

## Commande dans le terminal

Il suffit de coller la commande copi√©e dans le presse-papiers (*clipboard*).

```
python multiplot.py "../logs/YYYY-MM-DD/HH-MM-SS.csv"
```

Remarquez que `YYYY-MM-DD` repr√©sente l'ann√©e, le mois et le jour, tandis que `HH-MM-SS` repr√©sente l'heure, la minute et la seconde o√π le *log* a √©t√© g√©n√©r√©. Il sera unique pour chaque course et garantit que les *logs* ne se chevauchent pas.

Pour modifier le moment dans le temps des graphiques, utilisez le *slider* en bas √† gauche. Pour un contr√¥le plus pr√©cis, utilisez les fl√®ches du clavier pour passer it√©ration par it√©ration. Appuyez sur la touche `CTRL` tout en utilisant les fl√®ches du clavier pour augmenter la taille du pas.

# D√©tails de l'algorithme

## Architecture

L'architecture du code principal peut √™tre abstraite en 3 parties : initialisation, ex√©cution et terminaison.

Le dictionnaire appel√© `interface` contient les objets qui contr√¥lent le lidar, chacun des PWM et la communication s√©rie. Ces 4 objets ont √©t√© associ√©s √† un seul dictionnaire pour faciliter l'acc√®s √† ces √©l√©ments lorsque d'autres fonctions en ont besoin, de sorte qu'il suffit de les instancier une seule fois et que la r√©f√©rence des objets est utilis√©e en permanence.

La communication s√©rie contient un petit code qui v√©rifie de mani√®re r√©cursive si cette m√™me communication fonctionne correctement. En cas de probl√®me de communication pendant la course, le code identifiera simplement que l'Arduino n'est plus disponible et enverra des valeurs fictives pour ne pas arr√™ter le contr√¥le de la voiture.

‚ö†Ô∏è **Important :** comme le lidar prend environ 1 seconde pour commencer √† renvoyer des mesures, une strat√©gie a √©t√© adopt√©e pour l'initialiser avant de donner le signal de d√©part, ce qui r√©duit consid√©rablement la latence.

La mani√®re dont le code principal a √©t√© √©crit privil√©gie la scalabilit√© et la g√©n√©ralit√© du projet. Pour modifier le comportement du v√©hicule, il suffit de modifier les lois de contr√¥le.

## Mesure du lidar

La mesure du lidar se compose d'un vecteur de 360 positions de nombres flottants o√π l'indice repr√©sente l'angle en degr√©s dans le rep√®re du lidar et la valeur allou√©e √† cette position correspond √† la distance respective en m√®tres. Par exemple, l'√©l√©ment √† la position 90 √©quivaut √† la distance mesur√©e sur le c√¥t√© gauche du lidar (pas n√©cessairement √† gauche de la voiture).

‚ùóÔ∏è**Notez** que les angles sont mesur√©s dans le sens antihoraire.

Le module `rplidar` poss√®de la fonction `iter_scans()` qui permet d'it√©rer sur les balayages du lidar. Il est √† noter que chaque balayage contiendra les distances mesur√©es pour un petit intervalle angulaire, de sorte que nous devons regrouper plusieurs de ces balayages pour composer une mesure du lidar. Lorsque le vecteur de distances comporte plus de 60 points non nuls, il est alors consid√©r√© que la mesure est suffisante pour progresser dans le code.

‚ö†Ô∏è **Important :** comme le module `rplidar` utilise un g√©n√©rateur pour impl√©menter la fonction `iter_scans()`, le code de contr√¥le doit √™tre suffisamment rapide pour ne pas g√©n√©rer d'accumulation de balayages et surcharger le *buffer*.

## Loi de direction

La premi√®re chose √† faire est de filtrer le nuage de points du lidar et de s√©parer la r√©gion d'int√©r√™t principale. La fonction `filter` s√©lectionnera uniquement les points qui se trouvent dans un certain champ de vision du v√©hicule. Ce champ de vision est calcul√© √† partir de l'avant de la voiture et d'une ouverture donn√©e (la moiti√© de chaque c√¥t√©). Ensuite, une convolution sera appliqu√©e pour lisser et r√©duire les erreurs. On peut comprendre la convolution comme une moyenne entre les points voisins.

![figure 2](images/2.png)
**Figure 2.** **(a)** mesure brute du lidar **(b)** champ de vision du v√©hicule **(c)** nuage de points liss√© par une convolution avec `CONVOLUTION_SIZE = 31`.

Augmentez `CONVOLUTION_SIZE` pour augmenter cette voisinage et, par cons√©quent, le lissage effectu√©.

![figure 3](images/3.png)
**Figure 3.** **(a)** `CONVOLUTION_SIZE = 11` **(b)** `CONVOLUTION_SIZE = 21` **(c)** `CONVOLUTION_SIZE = 31`.

‚ùóÔ∏èNotez que l'augmentation de la taille de la convolution a tendance √† mieux r√©partir les points, ce qui finit par combler les lacunes.

Maintenant que le nuage de points a √©t√© correctement trait√©, on trouvera l'angle associ√© au point le plus √©loign√©. De l√©g√®res perturbations seront appliqu√©es vers la droite et vers la gauche de cet angle afin de v√©rifier si la voiture atteindrait d'√©ventuels coins de la piste. Notez que pour v√©rifier la pr√©sence de coins, on utilise la mesure non filtr√©e, car le vecteur filtr√© aura les coins liss√©s.

![figure 4](images/4.png)
**Figure 4.** **(a)** le point le plus √©loign√© pour le nuage de points liss√© **(b)** la direction du point le plus √©loign√©, mais dans la mesure brute **(c)** la r√©gion o√π la direction sera vari√©e pour rechercher les coins. Dans ce cas, coin non trouv√© des deux c√¥t√©s, donc `delta = 0`.

Supposons qu'un coin a √©t√© trouv√© √† droite du v√©hicule, `r_angle`, alors on d√©placera l'angle de direction vers la gauche afin d'√©viter de heurter l'obstacle. Dans ce cas, ce d√©placement serait donn√© par :

```python
delta = -ANGLE_SCALE_FACTOR * (MAX_ANGLE_TO_AVOID_CORNER - r_angle)
```

Les constantes `ANGLE_SCALE_FACTOR` et `MAX_ANGLE_TO_AVOID_CORNER` contr√¥lent le facteur d'augmentation de ce d√©placement et la taille de la perturbation angulaire.

Ainsi, on peut calculer l'angle de direction corrig√© $\alpha$. Cependant, l'angle de braquage effectif des roues $\delta$ sera une fonction de $\alpha$. Cette fonction $f$ est d√©finie dans `STEER_FACTOR` par une carte de points interpol√©s lin√©airement.

$$\delta(\alpha) = \text{sign}(\alpha) \cdot f(|\alpha|)$$

‚ö†Ô∏è **Important :** un angle de braquage positif indique que la voiture doit tourner √† gauche et une valeur n√©gative √† droite.

## Loi de vitesse

Avec le braquage $\delta$ calcul√©, il est temps de passer √† la vitesse. Un petit c√¥ne sera filtr√© dans la r√©gion frontale du v√©hicule afin de calculer sa distance frontale $d_f$. La vitesse $v$ sera une fonction de $d_f$ et de $\delta$ de la mani√®re suivante :

$$v(d_f, \delta) = \kappa + (1-\kappa) \cdot g(d_f) \cdot h(|\delta|)$$

o√π $\kappa$ est une constante qui d√©termine l'agressivit√© de la direction. Plus proche de 1, moins la voiture freinera dans les virages, mais le risque de perdre le contr√¥le est √©galement plus √©lev√©. Les fonctions $g$ et $h$ sont d√©finies respectivement dans `SPEED_FACTOR_DIST` et `SPEED_FACTOR_ANG` √† l'aide de cartes de points interpol√©s lin√©airement.

‚ùóÔ∏è**Remarquez** que la fonction $h$ vise √† acc√©l√©rer dans les lignes droites (petit braquage) et √† freiner encore plus dans les virages, augmentant la r√©activit√© du v√©hicule.

## Interpolation lin√©aire

Tout au long du code, les fonctions $f$, $g$ et $h$ sont utilis√©es pour convertir une grandeur en une autre. Ces fonctions sont d√©termin√©es de mani√®re empirique, donc des cartes d'interpolation sont utilis√©es, stock√©es sous forme de tableaux avec $n$ lignes et 2 colonnes. La $i$-√®me ligne repr√©sente le $i$-√®me point de la carte, tandis que les valeurs dans la ligne repr√©sentent l'entr√©e et la sortie de la fonction, respectivement.
$$f(x_i) = y_i \qquad i=1,2,\dots,n \qquad f(x > x_n) = y_n$$
$$x \in [x_i, x_{i+1}] \Rightarrow f(x) = y_i + (y_{i+1} - y_i) \cdot \dfrac{x - x_i}{x_{i+1} - x_i}$$

![figure 5](images/5.png)
**Figure 5.** visualisation des cartes mentionn√©es.

## D√©tection de la marche arri√®re

L'activation de la marche arri√®re peut se produire dans deux sc√©narios distincts :

1. le v√©hicule est √† l'arr√™t (capteur de vitesse nul) et le temps √©coul√© depuis la derni√®re activation est sup√©rieur √† 2 secondes ;
2. en obstacle frontal a √©t√© identifi√© pendant une p√©riode suffisante, c'est-√†-dire pendant au moins `REVERSE_CHECK_COUNTER` it√©rations.

Pour v√©rifier la pr√©sence d'un obstacle frontal, une zone de v√©rification rectangulaire est utilis√©e plut√¥t qu'un secteur circulaire, il est donc n√©cessaire de convertir la mesure du lidar de coordonn√©es polaires en coordonn√©es cart√©siennes. Cette zone aura une largeur fixe et approximativement √©gale √† la largeur de la voiture, cependant sa longueur variera avec la vitesse du v√©hicule.

Si la voiture roule plus vite, il est n√©cessaire d'augmenter la distance de v√©rification en raison du l√©ger d√©lai qui existe dans le freinage total du v√©hicule. La longueur varie selon la fonction mapp√©e dans `LENGTH_FACTOR`.

Si un nombre minimum `MIN_POINTS_TO_TRIGGER` de points se trouve dans cette zone rectangulaire, on conclut qu'il y a un obstacle frontal. Cependant, cet obstacle pourrait √™tre simplement une voiture qui a frein√© bri√®vement puis a rapidement d√©gag√© le chemin. Pour √©viter l'activation inutile de la marche arri√®re, il est n√©cessaire de v√©rifier si cet obstacle est rest√© pendant un minimum de `REVERSE_CHECK_COUNTER` it√©rations cons√©cutives. Si tel est le cas, la marche arri√®re est alors enclench√©e.

## Activation de la marche arri√®re

Lors de l'activation de la marche arri√®re, le code effectuera les actions suivantes :

1. arr√™ter le lidar pour √©viter les erreurs d'obstruction du *buffer* ;
2. notifier l'ESC (contr√¥leur du moteur) qu'il doit fonctionner en mode inverse ;
3. v√©rifier si l'arri√®re est d√©gag√© pour effectuer la marche arri√®re ;
4. d√©cider du c√¥t√© sur lequel les roues tourneront lors de la marche arri√®re ;
5. r√©activer le lidar tout en effectuant correctement la marche arri√®re.

‚ö†Ô∏è **Important :** la proc√©dure de notification de l'ESC varie d'un mod√®le √† l'autre, il s'agira donc probablement d'un point de divergence entre les codes des deux voitures. Le `time.sleep(0.03)` peut √™tre insuffisant pour notifier correctement l'ESC, il peut donc √™tre n√©cessaire d'augmenter l√©g√®rement cette valeur.

La v√©rification avant de reculer √©tait une exigence pour l'homologation et consiste √† attendre tant qu'il y a un obstacle √† l'arri√®re. En augmentant le `range` du `for`, on augmente l'intervalle maximal d'attente avant que la marche arri√®re ne soit autoris√©e. Pour l'homologation, il peut √™tre int√©ressant d'utiliser une grande valeur, mais une petite valeur pour les courses elles-m√™mes.

Les roues seront tourn√©es en marche arri√®re afin d'am√©liorer le positionnement du v√©hicule apr√®s la marche arri√®re. Le c√¥t√© est choisi en observant les c√¥t√©s du v√©hicule. Par exemple, si le c√¥t√© droit est plus d√©gag√© (distance moyenne plus grande) que le c√¥t√© gauche, les roues seront tourn√©es vers la gauche et vice versa.

Pendant que le v√©hicule recule, il v√©rifie √©galement si l'espace reste libre pour pouvoir continuer. Si un obstacle obstrue l'arri√®re du v√©hicule, la marche arri√®re est interrompue et la voiture reprend sa marche en avant.

‚ö†Ô∏è **Important :** le lidar prend environ 1 seconde pour s'initialiser apr√®s arr√™ter. Ainsi, il est int√©ressant de profiter de ce temps d'initialisation pour commencer √† reculer.

# Points d'am√©lioration

La performance lors de la comp√©tition CoVAPSy 2024 √©tait excellente, mais voici quelques points qui pourraient √™tre am√©lior√©s :

- D√©viation plus efficace des obstacles fixes
- Identification du sens correct de la piste pour √©viter de rouler √† contresens

Pour d√©vier des obstacles de mani√®re plus efficace, il peut √™tre int√©ressant de revoir la loi de direction, en particulier le calcul du `delta`. Ma supposition est que lorsque l'obstacle est tr√®s proche, `r_angle = l_angle = 0`, ce qui entra√Æne toujours l'entr√©e dans le `else` et un virage √† droite. Dans ce cas, il pourrait √™tre int√©ressant de r√©fl√©chir √† une solution pour r√©soudre cette impasse en cas d'√©galit√©.

Pour identifier le sens correct de la piste, plusieurs approches sont possibles : cam√©ra pour identifier la couleur des murs, SLAM (*Simultaneous Localisation And Mapping*), odom√©trie avec IMU (*Inertial Measurement Unit* compos√©e d'un gyroscope et d'un acc√©l√©rom√®tre), entre autres. Ne vous limitez pas √† cela, utilisez-le simplement comme point de d√©part pour d'autres approches.

# Boot sur RPi 5

Utilisez le [`2023-12-05-raspios-bookworm-arm64.img.tar.xz`](https://downloads.raspberrypi.com/raspios_arm64/images/raspios_arm64-2023-12-06/2023-12-05-raspios-bookworm-arm64.img.xz) pour d√©marrer le RPi 5.

‚ö†Ô∏è **Important :** le noyau utilis√© doit √™tre le 6.1 et il ne faut pas effectuer de mises √† jour, car le noyau 6.6 pr√©sentait certains probl√®mes au moment du d√©veloppement (mars 2024).

## Configuration PWM

Ex√©cutez la commande ci-dessous pour √©diter le fichier en question :

```
sudo nano /boot/firmware/config.txt
```

√Ä la fin du fichier, ajoutez les lignes suivantes :

```
# Enable PWM
dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4
```

Appuyez sur `CTRL+O` pour enregistrer et `CTRL+X` pour quitter l'√©diteur de texte. Red√©marrez le RPi.

## Cr√©ation d'un alias

Ex√©cutez les commandes ci-dessous pour cr√©er et √©diter un fichier de r√®gles :

```
sudo touch /etc/udev/rules.d/99-devices.rules
sudo nano /etc/udev/rules.d/99-devices.rules
```

Ajoutez les lignes suivantes :

```
SUBSYSTEM=="tty", ATTRS{idVendor}=="2341", ATTRS{idProduct}=="8057", SYMLINK+="ttyACM"
SUBSYSTEM=="tty", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="ea60", SYMLINK+="ttyUSB"
```

Appuyez sur `CTRL+O` pour enregistrer et `CTRL+X` pour quitter l'√©diteur de texte. Red√©marrez le RPi ou d√©branchez et rebranchez les p√©riph√©riques.

Les valeurs `idVendor` et `idProduct` peuvent √™tre trouv√©es en ex√©cutant la commande `dmesg`, mais il y a une forte probabilit√© qu'elles soient les m√™mes que celles de la commande ci-dessus.

Ainsi, il n'est pas n√©cessaire de sp√©cifier si le LiDAR est connect√© au port `ttyUSB0` ou `ttyUSB1`, par exemple, √©vitant les erreurs o√π le port change pendant l'ex√©cution du code.

# Contact

En cas de doutes, n'h√©sitez pas √† envoyer un message !

> Filipe **LACERDA**
>
> filipe.lacerda@ensta-paris.fr
>
> +33 7 82 74 86 81
