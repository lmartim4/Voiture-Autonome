# Voiture Autonome

![Raspberry Pi](https://img.shields.io/badge/-RaspberryPi-C51A4A?style=for-the-badge&logo=Raspberry-Pi)
![Arduino](https://img.shields.io/badge/-Arduino-00979D?style=for-the-badge&logo=Arduino&logoColor=white)
![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54)
![NumPy](https://img.shields.io/badge/numpy-%23013243.svg?style=for-the-badge&logo=numpy&logoColor=white)

# Table des mati√®res

* [Introduction](#introduction)
* [Premiers pas](#premiers-pas)
  * [Clonage](#clonage)
  * [Installation](#installation)
  * [Configuration](#configuration)
* [Calibration des actionneurs](#calibration-des-actionneurs)
* [Test de communication avec l'Arduino](#test-de-communication-avec-larduino)
* [Ex√©cution du code](#ex√©cution-du-code)
  * [Fichiers associ√©s](#fichiers-associc3a9s-2)
  * [Commande dans le terminal](#commande-dans-le-terminal-2)
* [Analyse du *log*](#analyse-du-log)
* [D√©tails de l'algorithme](#d√©tails-de-lalgorithme)
  * [Architecture](#architecture)
  * [Loi de direction](#loi-de-direction)
    * [Mesure du lidar](#mesure-du-lidar)
  * [Loi de vitesse](#loi-de-vitesse)
  * [Interpolation lin√©aire](#interpolation-lin√©aire)
  * [D√©tection de la marche arri√®re](#d√©tection-de-la-marche-arri√®re)
  * [Activation de la marche arri√®re](#activation-de-la-marche-arri√®re)
* [Boot sur RPi 5](#boot-sur-rpi-5)
  * [Configuration PWM](#configuration-pwm)
  * [Cr√©ation d'un alias](#cr√©ation-dun-alias)
* [Contact](#contact)

# Introduction

TODO

# Premiers pas

Pour prendre les premiers pas dans le projet, on doit d'abord t√©l√©charger le code et pr√©parer tout l'environnement dans lequel on travaillera.

## Clonage

Appuyez sur `CTRL+ALT+T` pour ouvrir un terminal et ex√©cutez les commandes ci-dessous (un par ligne) :

```
cd Desktop
git clone https://github.com/l4cer/Voiture-Autonome.git
cd Voiture-Autonome/code_24
```

## Installation

Cr√©ez un environnement virtuel et installez les modules n√©cessaires :

```
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

‚ö†Ô∏è **Important :** pour toutes les sections ci-dessous, ex√©cutez les commandes √† l'int√©rieur du dossier `code_24` et avec l'environnement virtuel activ√© !

## Configuration

- Dans le fichier `core.py`, indiquez √† la ligne 10 si le RPi utilis√© est le 5 ou non.
- Dans le fichier `main.py`, indiquez dans les lignes 38 √† 41 les param√®tres du mat√©riel utilis√©, le *baudrate*, etc.
- Dans le fichier `constants.py`, indiquez √† la ligne 10 l'orientation du LiDAR (angle dans le rep√®re du LiDAR o√π se trouve l'avant du v√©hicule).

# Calibration des actionneurs

Les actionneurs du v√©hicule sont contr√¥l√©s par une technique appel√©e [PWM](https://learn.sparkfun.com/tutorials/pulse-width-modulation/all) (*Pulse Width Modulation*), o√π la position du servomoteur et la vitesse du moteur *brushless* d√©pendent du *duty cycle* appliqu√©. La calibration consiste pr√©cis√©ment √† trouver ces valeurs de *duty cycle* qui permettent √† la direction de tourner au maximum dans les deux sens, ainsi que la valeur qui limitera la vitesse maximale du v√©hicule.

## Fichiers associ√©s

üìÅ `calibrate.py` est le code responsable de la calibration des actionneurs du v√©hicule (servomoteur pour la direction et moteur *brushless* pour la traction). En ex√©cutant ce code, on pourra contr√¥ler manuellement chacun des actionneurs √† partir d'une interface graphique de calibration et de test.

## Commande dans le terminal

```
python calibrate.py
```

Apr√®s avoir ferm√© l'interface graphique, le programme mettra √† jour automatiquement le fichier `constants.py`.

# Test de communication avec l'Arduino

La connexion s√©rie entre le Raspberry Pi et l'Arduino Nano se fait √† l'aide d'un c√¢ble USB vers mini USB. Cette m√™me connexion peut √™tre utilis√©e pour t√©l√©verser des programmes du RPi vers l'Arduino.

## Fichiers associ√©s

üìÅ `arduino.py` est le code responsable de tester la communication s√©rie entre le RPi et l'Arduino. En ex√©cutant ce code, on pourra visualiser les mesures des capteurs envoy√©es de mani√®re s√©rielle par l'Arduino et re√ßues par le RPi.

## Commande dans le terminal

```
python arduino.py
```

Les valeurs re√ßues par la communication s√©rie avec l'Arduino seront affich√©es sous le format :

```
capteur_de_vitesse/distance_de_recul/tension_de_la_batterie
```

Les unit√©s de chaque quantit√© sont respectivement `m/s`, `cm` et `volt`.

# Ex√©cution du code

Maintenant que tout est correctement pr√©par√©, on attache les ceintures ! üèÅ

## Fichiers associ√©s

üìÅ `console.py` est le code responsable de g√©rer les messages imprim√©s dans le terminal et de cr√©er et g√©rer les *logs* de chaque ex√©cution du code principal. Ce code n'est pas ex√©cut√© directement, mais utilis√© par `main.py`. Lorsqu'un objet de la classe `Console` est instanci√©, un dossier `YYYY-MM-DD` avec la date du test est cr√©√© (s'il n'existe pas d√©j√†) et un fichier `HH-MM-SS.csv` √† l'int√©rieur o√π toutes les donn√©es du test ou de la course sont stock√©es.

üìÅ `constants.py` est le code responsable de stocker toutes les constantes qui contr√¥lent le comportement du v√©hicule. Ce code n'est pas ex√©cut√© directement, mais utilis√© par d'autres fichiers. Certaines valeurs sont modifi√©es automatiquement lorsque la calibration des actionneurs est r√©alis√©e, minimisant l'effort et maximisant l'int√©gration du projet.

üìÅ `control.py` est le code responsable de d√©finir les lois de contr√¥le du v√©hicule √† partir des donn√©es sensorielles. On aura une session plus loin pour expliquer en d√©tail les lois de direction et de vitesse. Ce code n'est pas ex√©cut√© directement, mais utilis√© par `main.py`.

üìÅ `core.py` est le code responsable de d√©finir certaines structures de base qui seront utiles dans d'autres parties du projet, telles qu'un contr√¥leur PWM et un gestionnaire de communication s√©rie. Ce code n'est pas ex√©cut√© directement, mais utilis√© par d'autres fichiers.

üìÅ `main.py` est le code responsable de r√©aliser toute la routine d'initialisation des capteurs et actionneurs, le contr√¥le du v√©hicule pendant la course et la fermeture correcte de toutes les structures initialis√©es. Il unit les autres composants du projet. En ex√©cutant ce code, le v√©hicule sera correctement initialis√©, entrant dans une routine d'attente jusqu'√† ce que le signal GO soit donn√© pour le d√©but de la course. Pour arr√™ter le v√©hicule, il suffit d'appuyer sur `CTRL+C`, ce qui ferme les structures initialis√©es. Deux touches sont utilis√©es pour √©viter les arr√™ts accidentels du v√©hicule.

## Commande dans le terminal

```
python main.py
```

Appuyez sur `ENTER` pour d√©marrer et sur `CTRL+C` pour arr√™ter le code.

‚ö†Ô∏è **Important :** la commande exacte pour analyser le *log* g√©n√©r√© apr√®s la fin de la course sera copi√©e dans le presse-papiers (*clipboard*).

# Analyse du *log*

IMAGE HERE

## Fichiers associ√©s

üìÅ `multiplot.py` est le code responsable d'interpr√©ter le fichier CSV du *log* et de tracer les graphiques de mani√®re s√©par√©e, permettant l'analyse et l'obtention d'aper√ßus de la mani√®re la plus rapide possible. En ex√©cutant ce code, un √©cran matplotlib avec 5 graphiques sera affich√©. Le graphique le plus √† gauche repr√©sente la mesure du lidar pour l'instant de temps en question, tandis que les 4 autres graphiques montreront une fen√™tre temporelle avec les mesures des m√©triques respectives (les grandeurs et unit√©s sont correctement identifi√©es dans l'interface elle-m√™me).

## Commande dans le terminal

Il suffit de coller la commande copi√©e dans le presse-papiers (*clipboard*).

```
python multiplot.py "../logs/YYYY-MM-DD/HH-MM-SS.csv"
```

Remarquez que `YYYY-MM-DD` repr√©sente l'ann√©e, le mois et le jour, tandis que `HH-MM-SS` repr√©sente l'heure, la minute et la seconde o√π le *log* a √©t√© g√©n√©r√©. Il sera unique pour chaque ex√©cution et garantit que les *logs* ne se chevauchent pas.

Pour modifier le moment dans le temps des graphiques, utilisez le *slider* en bas √† gauche. Pour un contr√¥le plus pr√©cis, utilisez les fl√®ches du clavier pour passer it√©ration par it√©ration. Appuyez sur la touche `CTRL` tout en utilisant les fl√®ches du clavier pour augmenter la taille du pas.

# D√©tails de l'algorithme

TODO

## Architecture

TODO

## Loi de direction

TODO

### Mesure du lidar

TODO

## Loi de vitesse

TODO

## Interpolation lin√©aire

TODO

## D√©tection de la marche arri√®re

TODO

## Activation de la marche arri√®re

TODO

# Boot sur RPi 5

Utilisez le [`2023-12-05-raspios-bookworm-arm64.img.tar.xz`](https://downloads.raspberrypi.com/raspios_arm64/images/raspios_arm64-2023-12-06/2023-12-05-raspios-bookworm-arm64.img.xz) pour d√©marrer le RPi 5.

‚ö†Ô∏è **Important :** le noyau utilis√© doit √™tre le 6.1 et il ne faut pas effectuer de mises √† jour, car le noyau 6.6 pr√©sentait certains probl√®mes au moment du d√©veloppement (mars 2024).

## Configuration PWM

Ex√©cutez la commande ci-dessous pour √©diter le fichier en question :

```
sudo nano /boot/firmware/config.txt
```

√Ä la fin du fichier, ajoutez les lignes suivantes :

```
# Enable PWM
dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4
```

Appuyez sur `CTRL+O` pour enregistrer et `CTRL+X` pour quitter l'√©diteur de texte. Red√©marrez le RPi.

## Cr√©ation d'un alias

Ex√©cutez les commandes ci-dessous pour cr√©er et √©diter un fichier de r√®gles :

```
sudo touch /etc/udev/rules.d/99-devices.rules
sudo nano /etc/udev/rules.d/99-devices.rules
```

Ajoutez les lignes suivantes :

```
SUBSYSTEM=="tty", ATTRS{idVendor}=="2341", ATTRS{idProduct}=="8057", SYMLINK+="ttyACM"
SUBSYSTEM=="tty", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="ea60", SYMLINK+="ttyUSB"
```

Appuyez sur `CTRL+O` pour enregistrer et `CTRL+X` pour quitter l'√©diteur de texte. Red√©marrez le RPi ou d√©branchez et rebranchez les p√©riph√©riques.

Les valeurs `idVendor` et `idProduct` peuvent √™tre trouv√©es en ex√©cutant la commande `dmesg`, mais il y a une forte probabilit√© qu'elles soient les m√™mes que celles de la commande ci-dessus.

Ainsi, il n'est pas n√©cessaire de sp√©cifier si le LiDAR est connect√© au port `ttyUSB0` ou `ttyUSB1`, par exemple, √©vitant les erreurs o√π le port change pendant l'ex√©cution du code.

# Contact

En cas de doutes, n'h√©sitez pas √† envoyer un message !

> Filipe **LACERDA**
>
> filipe.lacerda@ensta-paris.fr
>
> +33 7 82 74 86 81
